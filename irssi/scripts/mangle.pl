#!/usr/bin/perl
#
# by Szymon Sokol <szymon@hell.pl>
# ideas taken from BabelIRC by Stefan Tomanek
#

use strict;
use locale;
use utf8;
use Irssi 20020324;
use Irssi::TextUI;
use POSIX;
use Data::Dumper;
use Irssi::TextUI;

use vars qw($VERSION %IRSSI %HELP %channels %translations);
$VERSION = '2019071201';
%IRSSI = (
    authors     => 'Szymon Sokol',
    contact     => 'szymon@hell.pl',
    name        => 'mangle',
    description => 'translates your messages into Morse code, rot13 and other sillinesses.',
    sbitems     => 'mangle_sb',
    license     => 'GPLv2',
    url         => 'http://irssi.org/scripts/',
    changed     => $VERSION,
    modules     => 'Data::Dumper'
);  

# To work, this help requires scripthelp.pl by Maciek 'fahren' Freudenheim
$HELP{"mangle add"} = "/mangle add <translation> [<channel>]
Add a new translation entry for <channel> (default is current channel)";
$HELP{"mangle del"} = "/mangle del [<channel>]
Removes the translation for <channel> (default is current channel)";
$HELP{"mangle say"} = "/mangle say <translation> <message>
Says something to the current channel using given translation";
$HELP{"mangle load"} = "/mangle load 
Loads translations from file";
$HELP{"mangle save"} = "/mangle save 
Saves active translations to file";
$HELP{"mangle show"} = "/mangle show 
Shows active translations";
$HELP{"mangle list"} = "/mangle list 
Lists available translations";

# the endless possibilities for extensions here
%translations = (
  # CChheecckk  yyoouurr  dduupplleexx  sswwiittcchh
  "duplex" => sub { 
    my ($text) = @_;
    $text =~ s/./$&$&/g;
    return $text;
  },
  # TaLk LiKe ThIs - EvErY OtHeR LeTtEr Is UpPeRcAse
  "funky" => sub {
    my ($text) = @_;
    $text =~ s/(\w.)/\u$1/g;
    return $text;
  },
  # TalkLikeThis-NoSpaces,WordBeginsWithUppercase
  "gnome" => sub {
    my ($text) = @_;
    $text =~ s/\b(\w)/\u$1/g;
    $text =~ s/\s+//g;
    return $text;
  },

  # ds mangle by blap - double strike mathematical symbols
  "ds" => sub { 
    my %ds = (
    "A" => "ùî∏",
    "B" => "ùîπ",
    "C" => "‚ÑÇ",
    "D" => "ùîª",
    "E" => "ùîº",
    "F" => "ùîΩ",
    "G" => "ùîæ",
    "H" => "‚Ñç",
    "I" => "ùïÄ",
    "J" => "ùïÅ",
    "K" => "ùïÇ",
    "L" => "ùïÉ",
    "M" => "ùïÑ",
    "N" => "‚Ñï",
    "O" => "ùïÜ",
    "P" => "‚Ñô",
    "Q" => "‚Ñö",
    "R" => "‚Ñù",
    "S" => "ùïä",
    "T" => "ùïã",
    "U" => "ùïå",
    "V" => "ùïç",
    "W" => "ùïé",
    "X" => "ùïè",
    "Y" => "ùïê",
    "Z" => "‚Ñ§",
    "a" => "ùïí",
    "b" => "ùïì",
    "c" => "ùïî",
    "d" => "ùïï",
    "e" => "ùïñ",
    "f" => "ùïó",
    "g" => "ùïò",
    "h" => "ùïô",
    "i" => "ùïö",
    "j" => "ùïõ",
    "k" => "ùïú",
    "l" => "ùïù",
    "m" => "ùïû",
    "n" => "ùïü",
    "o" => "ùï†",
    "p" => "ùï°",
    "q" => "ùï¢",
    "r" => "ùï£",
    "s" => "ùï§",
    "t" => "ùï•",
    "u" => "ùï¶",
    "v" => "ùïß",
    "w" => "ùï®",
    "x" => "ùï©",
    "y" => "ùï™",
    "z" => "ùï´",
    "0" => "ùüò",
    "1" => "ùüô",
    "2" => "ùüö",
    "3" => "ùüõ",
    "4" => "ùüú",
    "5" => "ùüù",
    "6" => "ùüû",
    "7" => "ùüü",
    "8" => "ùü†",
    "9" => "ùü°"
    );
    my ($text) = @_;
    $text =~ s/./defined $ds{$&} ? $ds{$&} : "$&"/eg;
    return $text;
  },

  # curs cursive by blap - cursive (bold) script
  "curs" => sub { 
    my %curs = (
    "A" => "ùìê",
    "B" => "ùìë",
    "C" => "ùìí",
    "D" => "ùìì",
    "E" => "ùìî",
    "F" => "ùìï",
    "G" => "ùìñ",
    "H" => "ùìó",
    "I" => "ùìò",
    "J" => "ùìô",
    "K" => "ùìö",
    "L" => "ùìõ",
    "M" => "ùìú",
    "N" => "ùìù",
    "O" => "ùìû",
    "P" => "ùìü",
    "Q" => "ùì†",
    "R" => "ùì°",
    "S" => "ùì¢",
    "T" => "ùì£",
    "U" => "ùì§",
    "V" => "ùì•",
    "W" => "ùì¶",
    "X" => "ùìß",
    "Y" => "ùì®",
    "Z" => "ùì©",
    "a" => "ùì™",
    "b" => "ùì´",
    "c" => "ùì¨",
    "d" => "ùì≠",
    "e" => "ùìÆ",
    "f" => "ùìØ",
    "g" => "ùì∞",
    "h" => "ùì±",
    "i" => "ùì≤",
    "j" => "ùì≥",
    "k" => "ùì¥",
    "l" => "ùìµ",
    "m" => "ùì∂",
    "n" => "ùì∑",
    "o" => "ùì∏",
    "p" => "ùìπ",
    "q" => "ùì∫",
    "r" => "ùìª",
    "s" => "ùìº",
    "t" => "ùìΩ",
    "u" => "ùìæ",
    "v" => "ùìø",
    "w" => "ùîÄ",
    "x" => "ùîÅ",
    "y" => "ùîÇ",
    "z" => "ùîÉ"
    );
    my ($text) = @_;
    $text =~ s/./defined $curs{$&} ? $curs{$&} : "$&"/eg;
    return $text;
  },

  # vapor double-width by blap - 'vaporwave' script
  "vapor" => sub { 
    my %vapor = (
    " " => "  ",
    "A" => "Ôº°",
    "B" => "Ôº¢",
    "C" => "Ôº£",
    "D" => "Ôº§",
    "E" => "Ôº•",
    "F" => "Ôº¶",
    "G" => "Ôºß",
    "H" => "Ôº®",
    "I" => "Ôº©",
    "J" => "Ôº™",
    "K" => "Ôº´",
    "L" => "Ôº¨",
    "M" => "Ôº≠",
    "N" => "ÔºÆ",
    "O" => "ÔºØ",
    "P" => "Ôº∞",
    "Q" => "Ôº±",
    "R" => "Ôº≤",
    "S" => "Ôº≥",
    "T" => "Ôº¥",
    "U" => "Ôºµ",
    "V" => "Ôº∂",
    "W" => "Ôº∑",
    "X" => "Ôº∏",
    "Y" => "Ôºπ",
    "Z" => "Ôº∫",
    "a" => "ÔΩÅ",
    "b" => "ÔΩÇ",
    "c" => "ÔΩÉ",
    "d" => "ÔΩÑ",
    "e" => "ÔΩÖ",
    "f" => "ÔΩÜ",
    "g" => "ÔΩá",
    "h" => "ÔΩà",
    "i" => "ÔΩâ",
    "j" => "ÔΩä",
    "k" => "ÔΩã",
    "l" => "ÔΩå",
    "m" => "ÔΩç",
    "n" => "ÔΩé",
    "o" => "ÔΩè",
    "p" => "ÔΩê",
    "q" => "ÔΩë",
    "r" => "ÔΩí",
    "s" => "ÔΩì",
    "t" => "ÔΩî",
    "u" => "ÔΩï",
    "v" => "ÔΩñ",
    "w" => "ÔΩó",
    "x" => "ÔΩò",
    "y" => "ÔΩô",
    "z" => "ÔΩö",
    "0" => "Ôºê",
    "1" => "Ôºë",
    "2" => "Ôºí",
    "3" => "Ôºì",
    "4" => "Ôºî",
    "5" => "Ôºï",
    "6" => "Ôºñ",
    "7" => "Ôºó",
    "8" => "Ôºò",
    "9" => "Ôºô",
    '[' => 'Ôºª',
    ']' => 'ÔºΩ',
    '{' => 'ÔΩõ',
    '}' => 'ÔΩù',
    '(' => 'Ôºà',
    ')' => 'Ôºâ',
    '.' => 'Ôºé',
    ',' => 'Ôºå',
    '?' => 'Ôºü',
    '!' => 'ÔºÅ',
	'"' => chr(65282),
    '\'' => 'Ôºá',
    '#' => 'ÔºÉ',
    '$' => 'ÔºÑ',
    '%' => 'ÔºÖ',
    '^' => 'Ôºæ',
    '&' => 'ÔºÜ',
    '=' => 'Ôºù',
    '\\' => 'Ôºº',
    '/' => 'Ôºè',
    '`' => 'ÔΩÄ'
    );
    my ($text) = @_;
    $text =~ s/./defined $vapor{$&} ? $vapor{$&} : "$&"/eg;
    return $text;
  },

  # blox cypher by blap
  "blox" => sub { 
    my %blox = (
    "a" => "‚ñû",
    "b" => "‚ñç",
    "c" => "‚ñé",
    "d" => "‚ñÖ",
    "e" => "‚ñÉ",
    "f" => "‚ñö",
    "g" => "‚óº",
    "h" => "‚ñá",
    "i" => "‚ñò",
    "j" => "‚ñõ",
    "k" => "‚î´",
    "l" => "‚ñã",
    "m" => "‚ñÜ",
    "n" => "‚ñù",
    "o" => "‚ñú",
    "p" => "‚ñà",
    "q" => "‚ñÅ",
    "r" => "‚ñÑ",
    "s" => "‚ñú",
    "t" => "‚ñÄ",
    "u" => "‚ñå",
    "v" => "‚ññ",
    "w" => "‚ñô",
    "x" => "‚ñÇ",
    "y" => "‚ñó",
    "z" => "‚ñü",
    "0" => "‚ñä",
    "1" => "‚ñê",
    "2" => "‚ñî",
    "3" => "‚ñí",
    "4" => "‚ñè",
    "5" => "‚ñë",
    "6" => "‚ñ≤",
    "7" => "‚î£",
    "8" => "‚ñì",
    "9" => "‚ñº"
    );
    my ($text) = @_;
    $text = lc($text);
    $text =~ s/./defined $blox{$&} ? $blox{$&} : "$&"/eg;
    return "‚ï≥".$text;
  },

  "morse" => sub { 
    my %morse = (
    " " => "",
    "a" => ".-",
    "b" => "-...",
    "c" => "-.-.",
    "d" => "-..",
    "e" => ".",
    "f" => "..-.",
    "g" => "--.",
    "h" => "....",
    "i" => "..",
    "j" => ".---",
    "k" => "-.-",
    "l" => ".-..",
    "m" => "--",
    "n" => "-.",
    "o" => "---",
    "p" => ".--.",
    "q" => "--.-",
    "r" => ".-.",
    "s" => "...",
    "t" => "-",
    "u" => "..-",
    "v" => "...-",
    "w" => ".--",
    "x" => "-..-",
    "y" => "-.--",
    "z" => "--..",
    # notice: Polish and German diacritical characters have their own 
    # Morse codes; the same probably stands true for other languages
    # using ISO-8859-2 - if you happen to know them, please send me e-mail
    "¬±" => ".-.-",
    "√¶" => "-.-..",
    "√™" => "..-..",
    "¬≥" => ".-..-",
    "√±" => "--.-",
    "√≥" => "---.".
    "¬∂" => "...-...",
    "¬º" => "--..",
    "¬ø" => "--..-",
    '√§'=>'.-.-',
    '√∂'=>'---.',
    '√º'=>'..--',
    "0" => "-----",
    "1" => ".----",
    "2" => "..---",
    "3" => "...--",
    "4" => "....-",
    "5" => ".....",
    "6" => "-....",
    "7" => "--...",
    "8" => "---..",
    "9" => "----.",
    "'" => ".----.",
    '"' => ".-..-.",
    '.' => ".-.-.-",
    ',' => "--..--",
    '?' => "..--..",
    ':' => "---...",
    ';' => "-.-.-.",
    '-' => "-....-",
    '_' => "..--.-",
    '/' => "-..-.",
    '(' => "-.--.",
    ')' => "-.--.-",
    '@' => ".--.-.", #  byFlorian Ernst <florian@uni-hd.de>
    '=' => "-...-"
    );
    my ($text) = @_;
    $text = lc($text);
    $text =~ s/./defined $morse{$&} ? $morse{$&}." " : ""/eg;
    return $text.'[morse]';
  },

  # Fraktur font by blap
  "frakt" => sub { 
    my %HoA = (
    'a' => ["ùñÜ"],
    'b' => ["ùñá"],
    'c' => ["ùñà"],
    'd' => ["ùñâ"],
    'e' => ["ùñä"],
    'f' => ["ùñã"],
    'g' => ["ùñå"],
    'h' => ["ùñç"],
    'i' => ["ùñé"],
    'j' => ["ùñè"],
    'k' => ["ùñê"],
    'l' => ["ùñë"],
    'm' => ["ùñí"],
    'n' => ["ùñì"],
    'o' => ["ùñî"],
    'p' => ["ùñï"],
    'q' => ["ùññ"],
    'r' => ["ùñó"],
    's' => ["ùñò"],
    't' => ["ùñô"],
    'u' => ["ùñö"],
    'v' => ["ùñõ"],
    'w' => ["ùñú"],
    'x' => ["ùñù"],
    'y' => ["ùñû"],
    'z' => ["ùñü"],
    'A' => ["ùï¨"],
    'B' => ["ùï≠"],
    'C' => ["ùïÆ"],
    'D' => ["ùïØ"],
    'E' => ["ùï∞"],
    'F' => ["ùï±"],
    'G' => ["ùï≤"],
    'H' => ["ùï≥"],
    'I' => ["ùï¥"],
    'J' => ["ùïµ"],
    'K' => ["ùï∂"],
    'L' => ["ùï∑"],
    'M' => ["ùï∏"],
    'N' => ["ùïπ"],
    'O' => ["ùï∫"],
    'P' => ["ùïª"],
    'Q' => ["ùïº"],
    'R' => ["ùïΩ"],
    'S' => ["ùïæ"],
    'T' => ["ùïø"],
    'U' => ["ùñÄ"],
    'V' => ["ùñÅ"],
    'W' => ["ùñÇ"],
    'X' => ["ùñÉ"],
    'Y' => ["ùñÑ"],
    'Z' => ["ùñÖ"]
    );
    my ($text) = @_;
    $text =~ s/./defined $HoA{$&} ? $HoA{$&}[rand(@{$HoA{$&}})] : "$&"/eg;
    return $text;
  },

  # Unicode Obfusticator by blap
  "obfus" => sub { 
    my %HoA = (
    '0' => ["”®","·Ωà","·ªí","·ªî","Œò","«ë","»é","œ¥","√í","√ï","√î","«æ"],
    '1' => ["ƒ¨","·º∏","ƒ™","”Ä","Œä","Œô","–Ü","–á","·øò","·øô","·øö"],
    '2' => ["∆ª","∆®"],
    '3' => ["∆∑","”†","“ò","“ô","”û","–∑","’Ö","–ó","…ù"],
    '4' => ["–ß"],
    '5' => ["∆º"],
    '6' => ["«ù","…ô"],
    '7' => ["7"],
    '8' => ["’ë"],
    '9' => ["9"],
    'a' => ["·ºÖ","·ºÅ","·∫ö","”ì","·Ω±","·æ∑","·æ∂","·æ±","«é","«ü","Œ¨","…ë"],
    'b' => ["∆É","∆Ö","√æ","·∏É","·∏Ö","·∏á","œ∏","…ì"],
    'c' => ["ƒã","ƒá","∆à","‚ÖΩ","œõ","√ß","œÇ","œ≤"],
    'd' => ["∆å","·∏ë","‚Öæ","·∏ã","·∏ç","·∏è","’™","…ó","…ñ"],
    'e' => ["—ë","ƒó","·ªá","—≥","·∏ï","·∏ù","√®","√™","œ±","»©","Œµ"],
    'f' => ["“ì","∆í","≈ø","·∫õ","œù","·∏ü"],
    'g' => ["ƒü","ƒ£","…°","«•","«ß","÷Å","’£","«µ","·∏°","…ï"],
    'h' => ["ƒ•","“ª","·∫ñ","…ß","…¶","’´","·∏©","·∏´","’∞"],
    'i' => ["ƒ©","ƒ´","·º≤","…©","¬°","√≠","√¨","Œê","ŒØ","Œπ","·∏≠"],
    'j' => ["—ò","ƒµ"," ù","»∑","«∞","’µ"],
    'k' => ["“ù","∆ô","ƒ∏","ƒ∑","–∫","·∏±","·∏≥","Œ∫"],
    'l' => ["≈Ç","≈Ä","∆ö","ƒæ","ƒ∫","…´","«Ä","…≠","…¨","·∏ª","·∏Ω"],
    'm' => ["‚Ç•","·πÉ","·πÅ","…±","·∏ø"],
    'n' => ["∆û","·º§","·πÖ","·Ωµ","√±","…¥","·æó","·æï","·æî","·øá","’º","’≤"],
    'o' => ["·ªõ","·ªü","·ΩÅ","≈è","≈ç","∆°","·Ω∏","·Ωπ","√≥","√≤"," ò","»´"],
    'p' => ["—Ä","“è","·πó","·πï","·ø§","·ø•","√æ","’©"],
    'q' => ["‘õ"," †","’¶","’£"],
    'r' => ["≈ó","≈ï","—ì","”∑","–≥","»ë","…Ω","…º"],
    's' => ["≈ü","≈õ","·πß","·π£","‘ë","≈°"," Ç"],
    't' => ["‚Ä†","·π´","≈•","»õ","’í","»∂"," à"],
    'u' => ["∆∞","·πª","·π≥","≈Ø","≈´","·ª•","·ªß","√π","¬µ","«ú","«ö"],
    'v' => ["·πø","·Ωê","·Ωó","·Ωî","·Ωª","—µ","“Ø","·ø†","·ø¢","‚Ö¥","Œ∞"],
    'w' => ["‘ù","·∫â","·∫É","·∫Å","≈µ","·∫á","·∫Ö"],
    'x' => ["·∫ã","“≥","·∫ç","œ∞"],
    'y' => ["—É","∆¥","”Ø","—û","·ªπ","·ªµ","·ª∑","·∫ô","√ø"],
    'z' => ["∆∂","≈æ","≈º","≈∫","·∫ì","·∫ë"," ë"],
    'A' => ["·∫®","·∫¨","ƒÑ","·ºé","”ê","·æª","·æπ","Œë","»∫","√É","·æâ","·æà"],
    'B' => ["∆Å","·∏Ç","·∏Ñ","Œí","–í"],
    'C' => ["ƒå","ƒà","ƒÜ","‚Çµ","“™","œæ","√á"],
    'D' => ["ƒê","∆ä","∆â","·∏í","·∏ä","·∏å","·∏é","√ê"],
    'E' => ["·∫∏","ƒò","·∫º","ƒî","·ªÜ","∆ê","‘ê","·∏ñ","·∏ú","·øà","»®"],
    'F' => ["“í","∆ë","‚Ç£","œù","œú"],
    'G' => ["ƒú","ƒû","ƒ†","ƒ¢","«§","·∏†","«¥"],
    'H' => ["ƒ§","”á","“§","“¢","»û","–ù","·∏§","·∏™"],
    'I' => ["·ªà","·ºπ","ƒ™","ƒ∞","»à","»ä","Œô","√ç","·∏¨","·øö","·∏Æ"],
    'J' => ["ƒ¥"," Ü","–à"],
    'K' => ["‚Ç≠","∆ò","ƒ∂","Œö","·∏∞","·∏≤","·∏¥","–ö","–å"],
    'L' => ["≈Å","ƒΩ","‚Ö¨","·∏∂","·∏∏","·∏∫","‚Ñí"],
    'M' => ["”ç","·πÇ","·πÄ","Œú","–ú","·∏æ"],
    'N' => ["≈á","≈Ö","≈É","‚Ç¶","·πä","·πà","√ë","«∏"],
    'O' => ["”™","·ªú","·ªî","·ªå","Œò","√ò","√í","√ï","»¨","»Æ"],
    'P' => ["∆§","“é","·πñ","·πî","‚Ç±","·ø¨","Œ°"],
    'Q' => ["‘ö"],
    'R' => ["≈ò","≈ñ","≈î","·πû","·πò","»ê"],
    'S' => ["œü","≈û","≈ú","·π†","≈†","»ò","’è"],
    'T' => ["·π∞","·πÆ","·π™","∆Æ","≈¶","≈¢","–¢","Œ§","·øõ"],
    'U' => ["·ª∞","≈≤","·ª®","·ª¨","≈®","»î","»ñ","«ï","«ó","«õ","√õ","√ö"],
    'V' => ["·πæ","·πº","—∂","‚ãÅ","‚Ö§"],
    'W' => ["‘ú","·∫à","·∫Ç","·∫Ä","≈¥","·∫Ü","·∫Ñ"],
    'X' => ["·∫ä","“≤","·∫å","–•","Œß"],
    'Y' => ["·ª∏","·∫é","“∞","≈∏","·ª≤","·ª¥","¬•","œì","»≤","Œ•"],
    'Z' => ["≈Ω","≈ª","≈π","·∫í","Œñ","»§"],
    );
    my ($text) = @_;
    $text =~ s/./defined $HoA{$&} ? $HoA{$&}[rand(@{$HoA{$&}})] : "$&"/eg;
    return $text;
  },

  # convert text in Polish from ISO-8859-2 to 7-bit approximation
  # if you know how to do it for other languages using 8859-2, 
  # please let me know
  "polskawe" => sub {
    my ($text) = @_;
    $text =~ y/¬°√Ü√ä¬£√ë√ì¬¶¬Ø¬¨¬±√¶√™¬≥√±√≥¬∂¬ø¬º/ACELNOSZZacelnoszz/;
    return $text;
  },
  # Ouch, my eyes!
  "rainbow" => sub {
    my ($text) = @_;
    # colors list
    #  0 == white
    #  4 == light red
    #  8 == yellow
    #  9 == light green
    # 11 == light cyan
    # 12 == light blue
    # 13 == light magenta
    my @colors = ('00','04','08','09','11','12','13');
    my $color;
    $text = join '', map { push @colors, $color = shift @colors;
"\003" . $color . ($_ eq "," ? ",," : $_) } split(//,$text);
    return $text;
  },
  # .drawkcab klaT
  "reverse" => sub {
    my ($text) = @_;
    $text = scalar reverse $text;
    return $text;
  },
  # Gnyx va ebg13 rapbqvat.
  "rot13" => sub {
    my ($text) = @_;
    $text =~ y/N-ZA-Mn-za-m/A-Za-z/;
    return $text.' [rot13]';
  },
  # T-T-Talk l-l-like y-y-you h-h-have a s-s-stutter.
  "stutter" => sub {
    my ($text) = @_;
    $text =~ s/(\w)(\w+)/$1-$1-$1$2/g;
    return $text;
  },
  # rmv vwls
  "vowels" => sub {
    my ($text) = @_;
    $text =~ y/aeiouy¬±√™//d;
    return $text;
  }
);

sub add_channel ($$) {
    my ($channel,$code) = @_;
    $channels{$channel} = $code;
}

sub save_channels {
    my $filename = Irssi::settings_get_str('mangle_filename');
	my $fo;
    open $fo, '>',$filename;
    my $data = Dumper(\%channels);
    print $fo $data;
    close $fo;
    print CLIENTCRAP "%R>>%n Mangle channels saved";
}

sub load_channels {
    my $filename = Irssi::settings_get_str('mangle_filename');
    return unless (-e $filename);
    my $fi;
    open $fi, '<',$filename;
    my $text;
    $text .= $_ foreach <$fi>;
    #no strict "vars";
    my $VAR1;
    eval "$text";
    %channels = %$VAR1;
}

sub mangle_show ($$) {
    my ($item, $get_size_only) = @_;
    my $win = !Irssi::active_win() ? undef : Irssi::active_win()->{active};
    if (ref $win && ($win->{type} eq "CHANNEL" || $win->{type} eq "QUERY") && $channels{$win->{name}}) {
        my $code = $channels{$win->{name}};
	$item->{min_size} = $item->{max_size} = length($code);
	$code = '%U%g'.$code.'%U%n';
	my $format = "{sb ".$code."}";
	$item->default_handler($get_size_only, $format, 0, 1);
    } else {
	$item->{min_size} = $item->{max_size} = 0;
    }
}
sub cmd_mangle ($$$) {
    my ($args, $server, $witem) = @_;
    my @arg = split(/ +/, $args);
    if ($arg[0] eq 'add' && defined $arg[1]) {
      my $code = $arg[1];
      if(exists $translations{$code}) {
        if (defined $arg[2]) { 
    	  add_channel($arg[2], $code);
        }
        elsif($witem) {
	  add_channel($witem->{name}, $code);
	}
      } else {
        Irssi::print("There is no such translation as $code !");
      }
    } elsif ($arg[0] eq 'del') {
        if(defined $arg[1]) {
	  delete $channels{$arg[1]} if defined $channels{$arg[1]};
	} elsif($witem) {
	  delete $channels{$witem->{name}} if defined $channels{$witem->{name}};
	}
    } elsif ($arg[0] eq 'say' && defined $arg[1]) {
      my $code = $arg[1];
      if(exists $translations{$code}) {
        if($witem) {
	  say($code, join(' ',@arg[2..$#arg]), $server, $witem);
	}
      } else {
        Irssi::print("There is no such translation as $code !");
      }
    } elsif ($arg[0] eq 'save') {
	save_channels();
    } elsif ($arg[0] eq 'load') {
	load_channels();
    } elsif ($arg[0] eq 'list') {
	Irssi::print("mangle: available translations are: ".
	join(" ", sort keys %translations));
    } elsif ($arg[0] eq 'show') {
        for (sort keys %channels) {
	  Irssi::print("mangle: ".$_." set to ".$channels{$_});
	}
    } else {
      Irssi::print("mangle v. $VERSION; use /help mangle for help (ensure you have scripthelp.pl loaded!)");
    }
    Irssi::statusbar_items_redraw('mangle_sb');
}

sub say ($$$$) {
    my ($code, $line, $server, $witem) = @_;
    my $target = "";
    if ($line =~ s/^(\w+?: )//) {
      $target = $1;
    }
    $line = $translations{$code}->($line);
    $server->command('MSG '.$witem->{name}.' '.$target.$line);
}

sub event_send_text ($$$) {
    my ($line, $server, $witem) = @_;
    return unless ($witem && 
                  ($witem->{type} eq "CHANNEL" || $witem->{type} eq "QUERY") && 
                  $channels{$witem->{name}});
    say($channels{$witem->{name}}, $line, $server, $witem);
    Irssi::signal_stop();
    Irssi::statusbar_items_redraw('mangle_sb');
}

# main

Irssi::command_bind('mangle', \&cmd_mangle);
foreach my $cmd ('add', 'del', 'save', 'load', 'say', 'list', 'show') {
    Irssi::command_bind('mangle '.$cmd => sub {
		    cmd_mangle($cmd." ".$_[0], $_[1], $_[2]); });
}

Irssi::statusbar_item_register('mangle_sb', 0, "mangle_show");
Irssi::signal_add('setup saved', 'save_channels');
Irssi::signal_add('send text', \&event_send_text);
Irssi::signal_add('window changed', sub {Irssi::statusbar_items_redraw('mangle_sb');});

Irssi::settings_add_str($IRSSI{name}, 'mangle_filename', Irssi::get_irssi_dir()."/mangle_channels");
load_channels();
print CLIENTCRAP '%B>>%n '.$IRSSI{name}.' '.$VERSION.' loaded: /help mangle for help';

# ;-)
